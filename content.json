{"meta":{"title":"放手の风筝博客","subtitle":"放手の风筝博客","description":"java,java-web,vue,angular,react,spring,spring-boot,spring-cloud,百度,google","author":"kite","url":"https://mykite.github.io"},"pages":[{"title":"","date":"2017-04-17T05:16:47.764Z","updated":"2017-04-17T05:16:47.764Z","comments":true,"path":"index.html","permalink":"https://mykite.github.io/index.html","excerpt":"","text":"title: categories date: 2017-04-17 11:32:49"},{"title":"","date":"2017-04-17T05:55:42.720Z","updated":"2017-04-17T05:55:42.720Z","comments":true,"path":"about/index.html","permalink":"https://mykite.github.io/about/index.html","excerpt":"","text":"测试是否有用我勒个去title: about date: 2017-04-17 13:47:59"},{"title":"","date":"2017-04-17T05:16:56.587Z","updated":"2017-04-17T05:16:56.587Z","comments":true,"path":"tags/index.html","permalink":"https://mykite.github.io/tags/index.html","excerpt":"","text":"title: tags date: 2017-04-17 11:31:55"},{"title":"","date":"2017-04-17T06:13:28.933Z","updated":"2017-04-17T06:13:28.933Z","comments":false,"path":"categories/index.html","permalink":"https://mykite.github.io/categories/index.html","excerpt":"","text":"title: categories date: 2017-04-17 11:32:49"}],"posts":[{"title":"jvm 启动参数配置参考","slug":"jvm启动参数配置参考","date":"2017-04-17T07:01:22.687Z","updated":"2017-04-17T07:01:57.000Z","comments":true,"path":"2017/04/17/jvm启动参数配置参考/","link":"","permalink":"https://mykite.github.io/2017/04/17/jvm启动参数配置参考/","excerpt":"","text":"java -jar xxx.jar -Xms1024m -Xmx1024m -XX:NewSize=512m -XX:MaxNewSize=512m -XX:PermSize=256m -XX:MaxPermSize=256m -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection -XX:+CMSParallelRemarkEnabled -XX:+CMSPermGenSweepingEnabled -XX:+CMSClassUnloadingEnabled -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 -XX:+DisableExplicitGC -XX:+UseCompressedOops -XX:+DoEscapeAnalysis -XX:MaxTenuringThreshold=10 -verbose:gc -Xloggc:/alidata1/admin/logs/gc.log -XX:+PrintGCDetails","categories":[{"name":"jvm","slug":"jvm","permalink":"https://mykite.github.io/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://mykite.github.io/tags/jvm/"}]},{"title":"java命令","slug":"java命令","date":"2017-04-17T07:00:06.350Z","updated":"2017-04-17T07:00:47.000Z","comments":true,"path":"2017/04/17/java命令/","link":"","permalink":"https://mykite.github.io/2017/04/17/java命令/","excerpt":"","text":"演示命令12readme当前使用 pid=14750 jinfo:123查看Java进程的栈空间大小:jinfo - ThreadStackSize 14750查看是否使用了压缩指针:jinfo -flag UseCompressedOops 14750查看系统属性:jinfo -sysprops 14750 jstack: 1查看一个指定的Java进程中的线程的状态:jstack 14750 jstat: 1查看gc的信息:jstat -gcutil 14750 jmap&amp;mat 123空间中各个年龄段的空间的使用情况:jmap -heap 14750dump当前java运行状态jmap -dump:live,format=b,file=/fileName 14750 本文参考链接: http://www.javaranger.com/archives/1063","categories":[{"name":"jvm","slug":"jvm","permalink":"https://mykite.github.io/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://mykite.github.io/tags/jvm/"},{"name":"命令","slug":"命令","permalink":"https://mykite.github.io/tags/命令/"}]},{"title":"jvm内存模型","slug":"jvm内存模型","date":"2017-04-17T06:58:58.311Z","updated":"2017-04-17T06:59:53.474Z","comments":true,"path":"2017/04/17/jvm内存模型/","link":"","permalink":"https://mykite.github.io/2017/04/17/jvm内存模型/","excerpt":"","text":"内存模型方法区（methodArea）,java堆（heap）,java栈（stack）,本地方法栈（native Method Stack） 对象分为：年轻代(Young)、年老代(Tenured)、持久代(Perm)年轻代(Young)： 年轻代分三个区。一个Eden区，两个Survivor区。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制年老区(Tenured。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来 对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。 Tenured（年老代）年老代存放从年轻代存活的对象。一般来说年老代存放的都是生命期较长的对象。Perm（持久代） 用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=进行设置。 持久代(Perm)持久代是指MethodArea，不属于Heap。 本文参考链接：http://www.javaranger.com/archives/472","categories":[{"name":"jvm","slug":"jvm","permalink":"https://mykite.github.io/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://mykite.github.io/tags/jvm/"},{"name":"内存模型","slug":"内存模型","permalink":"https://mykite.github.io/tags/内存模型/"}]},{"title":"ArrayBlockingQueue源码解析","slug":"ArrayBlockingQueue源码解析","date":"2017-04-17T06:48:26.506Z","updated":"2017-04-17T06:56:57.319Z","comments":true,"path":"2017/04/17/ArrayBlockingQueue源码解析/","link":"","permalink":"https://mykite.github.io/2017/04/17/ArrayBlockingQueue源码解析/","excerpt":"","text":"什么是ArrayBlockingQueue ArrayBlockingQueue底层是由数组实现的定长阻塞队列(阻塞表示如果没有原始那么获取元素会阻塞当前线程) ArrayBlockingQueue用来干嘛 ArrayBlockingQueue一般用于生产者消费者模型业务(排队机制，先进先出) 源码解析数据的存储 12345678910111213141516public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123; private static final long serialVersionUID = -817911632652898426L; /** The queued items 存储元素容器*/ final Object[] items; /** items index for next take, poll, peek or remove 使用过的元素 */ int takeIndex; /** items index for next put, offer, or add 添加过的元素 */ int putIndex; /** Number of elements in the queue 当前元素数量 */ int count; 数据的操作add1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public boolean add(E e) &#123; return super.add(e);&#125;super.addpublic boolean add(E e) &#123; if (offer(e)) return true; else throw new IllegalStateException(&quot;Queue full&quot;);&#125;public boolean offer(E e) &#123; checkNotNull(e);//ArrayBlockingQueue不能存储null对象 final ReentrantLock lock = this.lock;//插入操作线程安全 lock.lock(); try &#123; if (count == items.length)//如果当前count==items.length表示队列已经忙了，不能插入 return false; else &#123; insert(e);//插入元素 return true; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125;private void insert(E x) &#123; items[putIndex] = x;//第一次put为0 putIndex = inc(putIndex);//递增 ++count;//数量递增 notEmpty.signal();//通知获取原始方法可以进行获取&#125;final int inc(int i) &#123;//如果当前putIndex==items.length那么putIndex重新从零开始 return (++i == items.length) ? 0 : i;&#125;//同样为添加元素，lock.lockInterruptibly如果检测到有Thread.interrupted();会直接抛出异常public void put(E e) throws InterruptedException &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == items.length) notFull.await(); insert(e); &#125; finally &#123; lock.unlock(); &#125;&#125; remove123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public boolean remove(Object o) &#123; if (o == null) return false; final Object[] items = this.items; final ReentrantLock lock = this.lock; lock.lock(); try &#123; for (int i = takeIndex, k = count; k &gt; 0; i = inc(i), k--) &#123; if (o.equals(items[i])) &#123;//从头部开始遍历元素判断 removeAt(i); return true; &#125; &#125; return false; &#125; finally &#123; lock.unlock(); &#125;&#125;//queue size = 10 putSize = 5 tackSize = 0//queue 1,2,3,4,5removeAt 3step1: removeAt != takeIndexi = nexti = 4void removeAt(int i) &#123; final Object[] items = this.items; // if removing front item, just advance if (i == takeIndex) &#123; items[takeIndex] = null;//引用设置为空 takeIndex = inc(takeIndex);//takeIndex++ &#125; else &#123; // slide over all others up through putIndex. for (;;) &#123; int nexti = inc(i);//&gt;队列的头部 递增(putIndex一个循环的0-n) if (nexti != putIndex) &#123;//递增后部位putIndex全部向前移动位置 items[i] = items[nexti]; i = nexti; &#125; else &#123; items[i] = null;//元素设置为空 putIndex = i; break; &#125; &#125; &#125; --count;//元素递减 notFull.signal();//通知notFull.awit()&#125; update12```get public E poll() {//获取队列头部元素，获取后设置为空 final ReentrantLock lock = this.lock; lock.lock(); try { return (count == 0) ? null : extract();//如果当前队列为空直接返回null,不为空调用extract() } finally { lock.unlock(); }}//获取队列头部元素，获取后设置为空//take获取原始如果队列为空会进入阻塞状态知道等到有添加元素才会去返回public E take() throws InterruptedException { final ReentrantLock lock = this.lock; lock.lockInterruptibly();//lock.lockInterruptibly如果检测到有Thread.interrupted();会直接抛出异常 try { while (count == 0) notEmpty.await();//如果没有元素进入等待状态，等待被唤醒 return extract(); } finally { lock.unlock(); }}//peek查看队列头部元素public E peek() { final ReentrantLock lock = this.lock; lock.lock(); try { return (count == 0) ? null : itemAt(takeIndex);//如果元素为空直接返回null,不为空条用itemAt(takeIndex) } finally { lock.unlock(); }}private E extract() { final Object[] items = this.items; E x = this.cast(items[takeIndex]);//泛型转换并且获得当前元素 items[takeIndex] = null;//当前元素设置为空 takeIndex = inc(takeIndex);//获取原始递增 –count;//队列元素递减 notFull.signal();//通知notFull.await()可以进行插入元素 return x;//返回当前获取原始}//获取元素final E itemAt(int i) { return this.cast(items[i]);}``` 什么时候扩容 定长队列，不能进行扩容 是否线程安全 线程安全 使用注意事项 ArrayBlockingQueue为定长队列 ArrayBlockingQueue的添加和获取方法都有提供阻塞和非阻塞的根据需要使用 引用 jdk源码","categories":[{"name":"Collection","slug":"Collection","permalink":"https://mykite.github.io/categories/Collection/"},{"name":"queue","slug":"Collection/queue","permalink":"https://mykite.github.io/categories/Collection/queue/"}],"tags":[{"name":"queue","slug":"queue","permalink":"https://mykite.github.io/tags/queue/"},{"name":"blockngQueue","slug":"blockngQueue","permalink":"https://mykite.github.io/tags/blockngQueue/"},{"name":"java","slug":"java","permalink":"https://mykite.github.io/tags/java/"},{"name":"源码分析","slug":"源码分析","permalink":"https://mykite.github.io/tags/源码分析/"}]},{"title":"LinkedBlockingQueue源码解析","slug":"LinkedBlockingQueue源码解析","date":"2017-04-17T06:47:16.504Z","updated":"2017-04-17T06:57:03.583Z","comments":true,"path":"2017/04/17/LinkedBlockingQueue源码解析/","link":"","permalink":"https://mykite.github.io/2017/04/17/LinkedBlockingQueue源码解析/","excerpt":"","text":"什么是LinkedBlockingQueue LinkedBlockingQueue底层是由节点链表实现的定长阻塞队列(阻塞表示如果没有原始那么获取元素会阻塞当前线程) LinkedBlockingQueue用来干嘛 LinkedBlockingQueue一般用于生产者消费者模型业务(排队机制，先进先出) 源码解析数据的存储123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123; private static final long serialVersionUID = -6903933977591709194L; /** * Linked list node class */ static class Node&lt;E&gt; &#123;//存储数据的节点 E item; Node&lt;E&gt; next; Node(E x) &#123; item = x; &#125; &#125; /** The capacity bound, or Integer.MAX_VALUE if none */ private final int capacity;//链表的最大长度，如果不设置值默认为Integer.MAX_VALUE /** Current number of elements */ private final AtomicInteger count = new AtomicInteger(0);//统计数量线程安全 /** * Head of linked list. * Invariant: head.item == null */ private transient Node&lt;E&gt; head;//头节点 /** * Tail of linked list. * Invariant: last.next == null */ private transient Node&lt;E&gt; last;//尾节点 /** Lock held by take, poll, etc */ private final ReentrantLock takeLock = new ReentrantLock();//tackLock /** Wait queue for waiting takes */ private final Condition notEmpty = takeLock.newCondition();//tackLock条件不为空 /** Lock held by put, offer, etc */ private final ReentrantLock putLock = new ReentrantLock();//putLock /** Wait queue for waiting puts */ private final Condition notFull = putLock.newCondition();//putLock条件没满 public LinkedBlockingQueue() &#123; this(Integer.MAX_VALUE); &#125; public LinkedBlockingQueue(int capacity) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.capacity = capacity; last = head = new Node&lt;E&gt;(null);//默认last=head=空节点 &#125; 数据的操作add123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public void put(E e) throws InterruptedException &#123; if (e == null) throw new NullPointerException();//不能存储空元素 int c = -1; Node&lt;E&gt; node = new Node(e);//创建节点 final ReentrantLock putLock = this.putLock;//获得putLock final AtomicInteger count = this.count;//获取当前数量 putLock.lockInterruptibly();//获取锁，如果有调用Thread.Interrupted()直接抛出异常 try &#123; while (count.get() == capacity) &#123;//如果当前队列以满，进入等待状态 notFull.await(); &#125; enqueue(node); c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125; if (c == 0) signalNotEmpty();&#125;public boolean offer(E e, long timeout, TimeUnit unit) offer(e)类似 throws InterruptedException &#123; if (e == null) throw new NullPointerException();//不能存储空元素 long nanos = unit.toNanos(timeout);//装换为纳秒 int c = -1; final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try &#123; while (count.get() == capacity) &#123; if (nanos &lt;= 0) return false; nanos = notFull.awaitNanos(nanos);//等待一段时间 &#125; enqueue(new Node&lt;E&gt;(e)); c = count.getAndIncrement();//递增 if (c + 1 &lt; capacity)//如果未满唤醒notFull.awit notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125; if (c == 0) signalNotEmpty();//唤醒notEmpty.await() return true;&#125;private void enqueue(Node&lt;E&gt; node) &#123; // assert putLock.isHeldByCurrentThread(); // assert last.next == null; //拆分为两步 last.next = node，last = node //每次head.next=当前的last然后last.next指向node last = last.next = node; &#125; remove12345678910111213141516171819202122232425262728public boolean remove(Object o) &#123; if (o == null) return false; fullyLock();//删除数据时全部lock try &#123; for (Node&lt;E&gt; trail = head, p = trail.next; p != null; trail = p, p = p.next) &#123; if (o.equals(p.item)) &#123; unlink(p, trail); return true; &#125; &#125; return false; &#125; finally &#123; fullyUnlock(); &#125;&#125;void unlink(Node&lt;E&gt; p, Node&lt;E&gt; trail) &#123; // assert isFullyLocked(); // p.next is not changed, to allow iterators that are // traversing p to maintain their weak-consistency guarantee. p.item = null; trail.next = p.next;//前后元素执行，大年元素设置为空 if (last == p) last = trail; if (count.getAndDecrement() == capacity)//count获取数量同时递减(获取数量为递减钱数量) notFull.signal();//唤醒 notFull.await()&#125; get123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//获取元素，消费，可能被中断public E take() throws InterruptedException &#123; E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly();//如果有调用Thread.Interrupted()抛出异常 try &#123; while (count.get() == 0) &#123; notEmpty.await();//元素为空进入等待状态 &#125; x = dequeue();// c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125; if (c == capacity) signalNotFull(); return x;&#125;//获取元素，消费public E poll() &#123; final AtomicInteger count = this.count; if (count.get() == 0) return null; E x = null; int c = -1; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try &#123; if (count.get() &gt; 0) &#123; x = dequeue(); c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); &#125; &#125; finally &#123; takeLock.unlock(); &#125; if (c == capacity) signalNotFull(); return x;&#125;//查看元素public E peek() &#123; if (count.get() == 0) return null; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try &#123; Node&lt;E&gt; first = head.next; if (first == null) return null; else return first.item; &#125; finally &#123; takeLock.unlock(); &#125;&#125;[null,aaa,bbb] queue[null,bbb] delete after queue去掉头部null元素获取aaa元素修改aaa元素的item=nullprivate E dequeue() &#123; // assert takeLock.isHeldByCurrentThread(); // assert head.item == null; Node&lt;E&gt; h = head; Node&lt;E&gt; first = h.next;//first第一个有值的节点 h.next = h; // help GC head = first; E x = first.item;//获取元素 first.item = null;//设置为空 return x;&#125; 什么时候扩容 定长链表不支持扩容 是否线程安全 线程安全 使用注意事项 默认创建方式链表醉大长度为Ineger.MAX_SIZE 引用 jdk源码","categories":[{"name":"Collection","slug":"Collection","permalink":"https://mykite.github.io/categories/Collection/"},{"name":"queue","slug":"Collection/queue","permalink":"https://mykite.github.io/categories/Collection/queue/"}],"tags":[{"name":"queue","slug":"queue","permalink":"https://mykite.github.io/tags/queue/"},{"name":"源码分析","slug":"源码分析","permalink":"https://mykite.github.io/tags/源码分析/"},{"name":"BlocingQueue","slug":"BlocingQueue","permalink":"https://mykite.github.io/tags/BlocingQueue/"},{"name":"LinkedBlockingQueue","slug":"LinkedBlockingQueue","permalink":"https://mykite.github.io/tags/LinkedBlockingQueue/"}]},{"title":"List总结","slug":"List总结","date":"2017-04-17T06:16:01.950Z","updated":"2017-04-17T06:56:01.000Z","comments":true,"path":"2017/04/17/List总结/","link":"","permalink":"https://mykite.github.io/2017/04/17/List总结/","excerpt":"","text":"对比1为体现差距使用 快，中等，一般 对比 增加 删除 修改 查询 ArrayList 快 一般 快 快 LinkedList 快 快 快 一般 copyOnWriteList 一般 一般 一般 快 ArrayList删除元素设计到元素的移动 LinkedList只能遍历(first last除外) copyOnWriteList增加删除都设计到数组的拷贝 闲话1copyOnWriteList没有实际使用过，感觉应用场景不多","categories":[{"name":"Collection","slug":"Collection","permalink":"https://mykite.github.io/categories/Collection/"},{"name":"List","slug":"Collection/List","permalink":"https://mykite.github.io/categories/Collection/List/"}],"tags":[]},{"title":"LinkedList源码解析","slug":"LinkedList源码解析","date":"2017-04-17T06:15:30.565Z","updated":"2017-04-17T06:55:58.034Z","comments":true,"path":"2017/04/17/LinkedList源码解析/","link":"","permalink":"https://mykite.github.io/2017/04/17/LinkedList源码解析/","excerpt":"","text":"什么是LinkedList ArrayList底层是由链表组成的一种数据结构，可以进行动态的增删改查 LinkedList用来干嘛 LinkedList一般用于对数据的存储 源码解析 数据的存储 数据的操作 什么时候扩容 是否线程安全 带上问题去找答案 数据的存储1234567891011121314151617public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; transient int size = 0; /** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */ transient Node&lt;E&gt; first; /** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */ transient Node&lt;E&gt; last; 数据的操作add (addFirst addLast类似)12345678910111213141516171819202122232425public boolean add(E e) &#123; linkLast(e); return true;&#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last;//获取last final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);//创建Node last = newNode;//last为新的节点 //如果当前l为空，表示是第一次添加，那么first也会=新的节点 //如果第一次添加就是first=last=newNode if (l == null) first = newNode; //l不为空也就是说不是第一次添加 //当前的last=newNode,而现在由于创建Node的时候已经吧newNode.prev=last也就是说现在是维护双向的关系 else l.next = newNode; size++; modCount++;&#125;//创建Node参数prev上一个，element当前元素，next下一个。添加的时候给定prev为last,element为当前，next为空Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev;&#125; 删除对象 linkedList可以存储null1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public boolean remove(Object o) &#123; //删除元素为空从first开始遍历判断为空 if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125;/*解除关系1.将当前Node的prev next item都设置为空2.将prev节点的next直接指向next(如果prev为空将first指向next)3.强next节点的prev直接指向prev(如果next为空将last指向prev)*/E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item;//当前元素 final Node&lt;E&gt; next = x.next;//当前元素的下一个节点 final Node&lt;E&gt; prev = x.prev;//当前元素的上一个节点 if (prev == null) &#123;//如果上一个节点为空，那么first将直接指向next first = next; &#125; else &#123; prev.next = next;//当前元素不为空将prev的next直接指向当前元素的下一个节点() x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 获取1因为是链表结构，只支持getFirst,getLast 什么时候扩容 链表没有终点不需要扩容 是否线程安全 线程不安全 使用注意事项 LinkedList不支持直接定位到元素 引用 jdk源码","categories":[{"name":"Collection","slug":"Collection","permalink":"https://mykite.github.io/categories/Collection/"},{"name":"List","slug":"Collection/List","permalink":"https://mykite.github.io/categories/Collection/List/"}],"tags":[]},{"title":"CopyOnWriteArrayList源码解析","slug":"CopyOnWriteArrayList源码解析","date":"2017-04-17T06:14:59.397Z","updated":"2017-04-17T06:57:26.000Z","comments":true,"path":"2017/04/17/CopyOnWriteArrayList源码解析/","link":"","permalink":"https://mykite.github.io/2017/04/17/CopyOnWriteArrayList源码解析/","excerpt":"","text":"什么是CopyOnWriteArrayList CopyOnWriteArrayList底层是由数组组成的一种数据结构，可以进行动态的增删改查 CopyOnWriteArrayList用来干嘛 CopyOnWriteArrayList一般用于对数据的存储(最好针对少量数据，添加会涉及到整个数组的复制) 源码解析 数据的存储 数据的操作 什么时候扩容 是否线程安全 带上问题去找答案 数据的存储 123456789public class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; private static final long serialVersionUID = 8673264195747942595L; /** 用于实现add的同步操作 */ transient final ReentrantLock lock = new ReentrantLock(); /** volatile针对读取时获取最新值，同时作为容器 */ private volatile transient Object[] array; 数据的操作123456789101112131415161718192021222324252627282930313233343536373839404142添加public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123;//同步操作 Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1);//添加操作设计到整个数组的复制，影响性能 newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125;删除public E remove(int index) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123;//同步代码 Object[] elements = getArray(); int len = elements.length; E oldValue = get(elements, index); int numMoved = len - index - 1; if (numMoved == 0) setArray(Arrays.copyOf(elements, len - 1));//数组复制 else &#123; Object[] newElements = new Object[len - 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index + 1, newElements, index, numMoved); setArray(newElements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125;&#125;获取public E get(int index) &#123;//基于volatile获取最新值 return get(getArray(), index);&#125; 什么时候扩容 每次添加删除，针对array做copy操作 是否线程安全基于Lock实现并发写入的安全，针对并发修改的读取，修改基于copy后的新数组，读取如果未set获取到的还是原数组。如果set后读取到的就是最新的值 使用注意事项 避免CopyOnWriteArrayList过长，copy影响性能 引用 jdk源码","categories":[{"name":"Collection","slug":"Collection","permalink":"https://mykite.github.io/categories/Collection/"},{"name":"List","slug":"Collection/List","permalink":"https://mykite.github.io/categories/Collection/List/"}],"tags":[{"name":"List","slug":"List","permalink":"https://mykite.github.io/tags/List/"},{"name":"集合框架","slug":"集合框架","permalink":"https://mykite.github.io/tags/集合框架/"},{"name":"CopyOnWriteArrayList","slug":"CopyOnWriteArrayList","permalink":"https://mykite.github.io/tags/CopyOnWriteArrayList/"}]},{"title":"ArrayList源码解析","slug":"ArrayList源码解析","date":"2017-04-17T06:14:18.183Z","updated":"2017-04-17T06:55:52.327Z","comments":true,"path":"2017/04/17/ArrayList源码解析/","link":"","permalink":"https://mykite.github.io/2017/04/17/ArrayList源码解析/","excerpt":"","text":"12345678910111213141516171819闲来无事,有空会继续写下ListLinkedListCopyOnWriteArrayListSetHashSetLinkedHashSetMapHashMapIdentityHashMapLinkedHashMapTreeMapConcurrentHashMapQueueArrayBlockingQueueLinkedBlockingQueueConcurrentLinkedQueue为节省空间对于非重点代码不做展示 什么是ArrayList ArrayList底层是由数组组成的一种数据结构，可以进行动态的增删改查 ArrayList用来干嘛 ArrayList一般用于对数据的存储 源码解析针对重要点 数据的存储 数据的操作 什么时候扩容 是否线程安全带上问题去找答案数据的存储123456789从我们使用ArrayList开始new ArrayList&lt;&gt;();public ArrayList() &#123; super(); this.elementData = EMPTY_ELEMENTDATA;&#125;private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;private transient Object[] elementData;elementData为储存数据所用容器，通过默认构造方法创建的ArrayList容器为空 数据的操作添加123456789101112131415161718public boolean add(E e) &#123; ensureCapacityInternal(size + 1); elementData[size++] = e;//size表示当前使用下表，直接将元素放入到elementData的指定位置 return true;&#125;指定位置的添加，设计到元素的后移 public void add(int index, E element) &#123; rangeCheckForAdd(index);//检查是否超出 ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index);//元素后裔 elementData[index] = element; size++;&#125;private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));//很常见的异常&#125; 删除123456789101112public E remove(int index) &#123; rangeCheck(index); checkForComodification(); E result = parent.remove(parentOffset + index); this.modCount = parent.modCount; this.size--; return result;&#125;final void checkForComodification() &#123; if (modCount != expectedModCount)//针对在对于list进行遍历时进行其他操作，modCount会改变，而expectedModCount值在listInterator时给定的会抛出异常 throw new ConcurrentModificationException();&#125; 查询1234 public E get(int index) &#123; rangeCheck(index);//这就没啥好多的了 return elementData(index);&#125; 什么时候扩容123456789101112131415161718192021222324252627282930313233343536 public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == EMPTY_ELEMENTDATA) &#123; //如果容器为空，初始化容器，两个值中取最大值 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++;//操作次数+1 // overflow-conscious code if (minCapacity - elementData.length &gt; 0) //扩容，当前元素数量已经等于容器了需要进行扩容 grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length;//当前容器大小 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);// oldCapacity + oldCapacity*0.5 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity);//计算是否超出 // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);//扩容&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow //如果为负数抛出内存溢出错误 throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? //还没有为负数，那么元素最大大小改为int的最大值，注意MAX_ARRAY_SIZE为最大值-8 Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125;private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 是否线程安全 ArrayList不是线程安全的 12345678 以添加为例 elementData[size++] = e; 一个 ArrayList ，在添加一个元素的时候，它可能会有两步来完成： 1. 在 Items[Size] 的位置存放此元素； 2. 增大 Size 的值。 在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1； 而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍然等于 0 （注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。 那好，现在我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不安全”了。 使用ArrayList的注意事项 arrayList不是线程安全的，不要有多个线程同时操作一个arrayList 不要在循环中对arrayList做其他操作，会引发异常 针对已经确定大小的List请直接传入参数，避免多次扩容 参考 为什么说ArrayList是线程不安全的？ jdk源码","categories":[{"name":"Collection","slug":"Collection","permalink":"https://mykite.github.io/categories/Collection/"},{"name":"List","slug":"Collection/List","permalink":"https://mykite.github.io/categories/Collection/List/"}],"tags":[]}]}